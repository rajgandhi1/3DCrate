//! OBJ format support with MTL material linking
//!
//! This module provides comprehensive OBJ (Wavefront OBJ) reading and writing
//! capabilities including:
//! - Vertices (v), texture coordinates (vt), normals (vn), faces (f)
//! - Groups/materials (usemtl, mtllib) with MTL file parsing
//! - Polygon triangulation for faces with more than 3 vertices
//! - Optional vertex-color support via conventions
//! - Robust error handling and streaming read capabilities

use crate::{MeshReader, MeshWriter};
use threecrate_core::{TriangleMesh, Result, Point3f, Vector3f, Error};
use std::path::{Path, PathBuf};
use std::fs::File;
use std::io::{BufRead, BufReader, BufWriter, Write};
use std::collections::HashMap;

/// Material properties from MTL files
#[derive(Debug, Clone)]
pub struct Material {
    /// Material name
    pub name: String,
    /// Ambient color (Ka)
    pub ambient: Option<[f32; 3]>,
    /// Diffuse color (Kd)
    pub diffuse: Option<[f32; 3]>,
    /// Specular color (Ks)
    pub specular: Option<[f32; 3]>,
    /// Specular exponent (Ns)
    pub shininess: Option<f32>,
    /// Transparency (d or Tr)
    pub transparency: Option<f32>,
    /// Illumination model (illum)
    pub illumination: Option<u32>,
    /// Diffuse texture map (map_Kd)
    pub diffuse_map: Option<String>,
    /// Normal map (map_Bump or bump)
    pub normal_map: Option<String>,
    /// Specular map (map_Ks)
    pub specular_map: Option<String>,
}

/// Face vertex with indices for position, texture coordinate, and normal
#[derive(Debug, Clone, Copy)]
pub struct FaceVertex {
    /// Vertex position index (required)
    pub vertex: usize,
    /// Texture coordinate index (optional)
    pub texture: Option<usize>,
    /// Normal index (optional)
    pub normal: Option<usize>,
}

/// Face definition
#[derive(Debug, Clone)]
pub struct Face {
    /// Vertices of the face
    pub vertices: Vec<FaceVertex>,
    /// Material used for this face (if any)
    pub material: Option<String>,
}

/// Group definition
#[derive(Debug, Clone)]
pub struct Group {
    /// Group name
    pub name: String,
    /// Faces in this group
    pub faces: Vec<Face>,
}

/// Complete OBJ file data
#[derive(Debug)]
pub struct ObjData {
    /// Vertex positions
    pub vertices: Vec<Point3f>,
    /// Texture coordinates
    pub texture_coords: Vec<[f32; 2]>,
    /// Vertex normals
    pub normals: Vec<Vector3f>,
    /// Groups
    pub groups: Vec<Group>,
    /// Materials referenced by this OBJ
    pub materials: HashMap<String, Material>,
    /// MTL file paths
    pub mtl_files: Vec<String>,
}

/// Enhanced OBJ reader with comprehensive format support
pub struct RobustObjReader;

/// OBJ reader (legacy interface)
pub struct ObjReader;

/// OBJ writer options
#[derive(Debug, Clone)]
pub struct ObjWriteOptions {
    /// Include vertex normals in output
    pub write_normals: bool,
    /// Include texture coordinates in output
    pub write_texcoords: bool,
    /// Generate and write MTL material file
    pub write_materials: bool,
    /// Comments to include in the header
    pub comments: Vec<String>,
    /// Object name
    pub object_name: Option<String>,
    /// Group name
    pub group_name: Option<String>,
    /// Material name for the mesh
    pub material_name: Option<String>,
    /// MTL file name (if different from OBJ name)
    pub mtl_filename: Option<String>,
}

impl Default for ObjWriteOptions {
    fn default() -> Self {
        Self {
            write_normals: true,
            write_texcoords: false,
            write_materials: false,
            comments: vec!["Generated by ThreeCrate".to_string()],
            object_name: None,
            group_name: None,
            material_name: None,
            mtl_filename: None,
        }
    }
}

impl ObjWriteOptions {
    /// Create new options with defaults
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Enable/disable normal writing
    pub fn with_normals(mut self, write_normals: bool) -> Self {
        self.write_normals = write_normals;
        self
    }
    
    /// Enable/disable texture coordinate writing
    pub fn with_texcoords(mut self, write_texcoords: bool) -> Self {
        self.write_texcoords = write_texcoords;
        self
    }
    
    /// Enable/disable material file generation
    pub fn with_materials(mut self, write_materials: bool) -> Self {
        self.write_materials = write_materials;
        self
    }
    
    /// Add a comment to the header
    pub fn with_comment<S: Into<String>>(mut self, comment: S) -> Self {
        self.comments.push(comment.into());
        self
    }
    
    /// Set object name
    pub fn with_object_name<S: Into<String>>(mut self, name: S) -> Self {
        self.object_name = Some(name.into());
        self
    }
    
    /// Set group name
    pub fn with_group_name<S: Into<String>>(mut self, name: S) -> Self {
        self.group_name = Some(name.into());
        self
    }
    
    /// Set material name
    pub fn with_material_name<S: Into<String>>(mut self, name: S) -> Self {
        self.material_name = Some(name.into());
        self
    }
    
    /// Set MTL filename
    pub fn with_mtl_filename<S: Into<String>>(mut self, filename: S) -> Self {
        self.mtl_filename = Some(filename.into());
        self
    }
}

/// Enhanced OBJ writer with comprehensive format support
pub struct RobustObjWriter;

/// OBJ writer (legacy interface)
pub struct ObjWriter;

impl Material {
    /// Create a new material with default properties
    pub fn new(name: String) -> Self {
        Self {
            name,
            ambient: None,
            diffuse: None,
            specular: None,
            shininess: None,
            transparency: None,
            illumination: None,
            diffuse_map: None,
            normal_map: None,
            specular_map: None,
        }
    }
}

impl Default for Material {
    fn default() -> Self {
        Self::new("default".to_string())
    }
}

impl FaceVertex {
    /// Parse face vertex from OBJ format string (e.g., "1", "1/2", "1/2/3", "1//3")
    fn parse(s: &str) -> Result<Self> {
        let parts: Vec<&str> = s.split('/').collect();
        
        if parts.is_empty() {
            return Err(Error::InvalidData("Empty face vertex".to_string()));
        }
        
        let vertex = parts[0].parse::<usize>()
            .map_err(|_| Error::InvalidData(format!("Invalid vertex index: {}", parts[0])))?;
        
        // OBJ uses 1-based indexing, convert to 0-based
        let vertex = vertex.checked_sub(1)
            .ok_or_else(|| Error::InvalidData("Vertex index cannot be 0".to_string()))?;
        
        let texture = if parts.len() > 1 && !parts[1].is_empty() {
            let tex_idx = parts[1].parse::<usize>()
                .map_err(|_| Error::InvalidData(format!("Invalid texture index: {}", parts[1])))?;
            Some(tex_idx.checked_sub(1)
                .ok_or_else(|| Error::InvalidData("Texture index cannot be 0".to_string()))?)
        } else {
            None
        };
        
        let normal = if parts.len() > 2 && !parts[2].is_empty() {
            let norm_idx = parts[2].parse::<usize>()
                .map_err(|_| Error::InvalidData(format!("Invalid normal index: {}", parts[2])))?;
            Some(norm_idx.checked_sub(1)
                .ok_or_else(|| Error::InvalidData("Normal index cannot be 0".to_string()))?)
        } else {
            None
        };
        
        Ok(FaceVertex { vertex, texture, normal })
    }
}

impl MeshReader for ObjReader {
    fn read_mesh<P: AsRef<Path>>(path: P) -> Result<TriangleMesh> {
        let obj_data = RobustObjReader::read_obj_file(path)?;
        RobustObjReader::obj_data_to_mesh(&obj_data)
    }
}

impl MeshWriter for ObjWriter {
    fn write_mesh<P: AsRef<Path>>(mesh: &TriangleMesh, path: P) -> Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);
        
        // Write header
        writeln!(writer, "# OBJ file generated by ThreeCrate")?;
        writeln!(writer, "# Vertices: {}", mesh.vertices.len())?;
        writeln!(writer, "# Faces: {}", mesh.faces.len())?;
        writeln!(writer)?;
        
        // Write vertices
        for vertex in &mesh.vertices {
            writeln!(writer, "v {} {} {}", vertex.x, vertex.y, vertex.z)?;
        }
        writeln!(writer)?;
        
        // Write normals if available
        if let Some(normals) = &mesh.normals {
            for normal in normals {
                writeln!(writer, "vn {} {} {}", normal.x, normal.y, normal.z)?;
            }
            writeln!(writer)?;
        }
        
        // Write faces
        if mesh.normals.is_some() {
            // Write faces with normals
            for face in &mesh.faces {
                writeln!(
                    writer,
                    "f {}//{} {}//{} {}//{}",
                    face[0] + 1, face[0] + 1,
                    face[1] + 1, face[1] + 1,
                    face[2] + 1, face[2] + 1
                )?;
            }
        } else {
            // Write faces without normals
            for face in &mesh.faces {
                writeln!(
                    writer,
                    "f {} {} {}",
                    face[0] + 1,
                    face[1] + 1,
                    face[2] + 1
                )?;
            }
        }
        
        Ok(())
    }
}

/// Read an OBJ file and return vertex positions only (useful for point clouds)
pub fn read_obj_vertices<P: AsRef<Path>>(path: P) -> Result<Vec<Point3f>> {
    let obj_data = RobustObjReader::read_obj_file(path)?;
    Ok(obj_data.vertices)
}

/// Write vertices as an OBJ file (useful for point clouds)
pub fn write_obj_vertices<P: AsRef<Path>>(vertices: &[Point3f], path: P) -> Result<()> {
    let file = File::create(path)?;
    let mut writer = BufWriter::new(file);
    
    writeln!(writer, "# OBJ vertices file generated by ThreeCrate")?;
    writeln!(writer, "# Vertices: {}", vertices.len())?;
    writeln!(writer)?;
    
    for vertex in vertices {
        writeln!(writer, "v {} {} {}", vertex.x, vertex.y, vertex.z)?;
    }
    
    Ok(())
}

impl RobustObjReader {
    /// Read a complete OBJ file with materials
    pub fn read_obj_file<P: AsRef<Path>>(path: P) -> Result<ObjData> {
        let path = path.as_ref();
        let file = File::open(path)
            .map_err(|e| Error::Io(e))?;
        let reader = BufReader::new(file);
        
        let mut obj_data = ObjData {
            vertices: Vec::new(),
            texture_coords: Vec::new(),
            normals: Vec::new(),
            groups: Vec::new(),
            materials: HashMap::new(),
            mtl_files: Vec::new(),
        };
        
        let mut current_group = Group {
            name: "default".to_string(),
            faces: Vec::new(),
        };
        let mut current_material: Option<String> = None;
        
        for (line_num, line) in reader.lines().enumerate() {
            let line = line.map_err(|e| Error::Io(e))?;
            let line = line.trim();
            
            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }
            
            match parts[0] {
                "v" => {
                    // Vertex position
                    if parts.len() < 4 {
                        return Err(Error::InvalidData(
                            format!("Invalid vertex at line {}: expected 3 coordinates", line_num + 1)
                        ));
                    }
                    
                    let x = parts[1].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid x coordinate at line {}", line_num + 1)))?;
                    let y = parts[2].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid y coordinate at line {}", line_num + 1)))?;
                    let z = parts[3].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid z coordinate at line {}", line_num + 1)))?;
                    
                    obj_data.vertices.push(Point3f::new(x, y, z));
                }
                "vt" => {
                    // Texture coordinate
                    if parts.len() < 3 {
                        return Err(Error::InvalidData(
                            format!("Invalid texture coordinate at line {}: expected 2 coordinates", line_num + 1)
                        ));
                    }
                    
                    let u = parts[1].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid u coordinate at line {}", line_num + 1)))?;
                    let v = parts[2].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid v coordinate at line {}", line_num + 1)))?;
                    
                    obj_data.texture_coords.push([u, v]);
                }
                "vn" => {
                    // Vertex normal
                    if parts.len() < 4 {
                        return Err(Error::InvalidData(
                            format!("Invalid normal at line {}: expected 3 components", line_num + 1)
                        ));
                    }
                    
                    let x = parts[1].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid normal x at line {}", line_num + 1)))?;
                    let y = parts[2].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid normal y at line {}", line_num + 1)))?;
                    let z = parts[3].parse::<f32>()
                        .map_err(|_| Error::InvalidData(format!("Invalid normal z at line {}", line_num + 1)))?;
                    
                    obj_data.normals.push(Vector3f::new(x, y, z));
                }
                "f" => {
                    // Face
                    if parts.len() < 4 {
                        return Err(Error::InvalidData(
                            format!("Invalid face at line {}: expected at least 3 vertices", line_num + 1)
                        ));
                    }
                    
                    let mut face_vertices = Vec::new();
                    for vertex_str in &parts[1..] {
                        let face_vertex = FaceVertex::parse(vertex_str)
                            .map_err(|e| Error::InvalidData(format!("Invalid face vertex '{}' at line {}: {}", vertex_str, line_num + 1, e)))?;
                        face_vertices.push(face_vertex);
                    }
                    
                    // Triangulate if necessary
                    let triangulated_faces = Self::triangulate_face(&face_vertices);
                    for triangle in triangulated_faces {
                        current_group.faces.push(Face {
                            vertices: triangle,
                            material: current_material.clone(),
                        });
                    }
                }
                "g" => {
                    // Group
                    if !current_group.faces.is_empty() || current_group.name != "default" {
                        obj_data.groups.push(current_group);
                    }
                    
                    let group_name = if parts.len() > 1 {
                        parts[1..].join(" ")
                    } else {
                        format!("group_{}", obj_data.groups.len())
                    };
                    
                    current_group = Group {
                        name: group_name,
                        faces: Vec::new(),
                    };
                }
                "usemtl" => {
                    // Use material
                    if parts.len() > 1 {
                        current_material = Some(parts[1].to_string());
                    }
                }
                "mtllib" => {
                    // Material library
                    if parts.len() > 1 {
                        let mtl_file = parts[1].to_string();
                        obj_data.mtl_files.push(mtl_file.clone());
                        
                        // Try to load the MTL file
                        let mtl_path = if let Some(parent) = path.parent() {
                            parent.join(&mtl_file)
                        } else {
                            PathBuf::from(&mtl_file)
                        };
                        
                        if let Ok(materials) = Self::read_mtl_file(&mtl_path) {
                            obj_data.materials.extend(materials);
                        }
                    }
                }
                _ => {
                    // Ignore unknown commands
                }
            }
        }
        
        // Add the last group if it has faces
        if !current_group.faces.is_empty() {
            obj_data.groups.push(current_group);
        }
        
        // If no groups were created, create a default group with all faces
        if obj_data.groups.is_empty() {
            obj_data.groups.push(Group {
                name: "default".to_string(),
                faces: Vec::new(),
            });
        }
        
        Ok(obj_data)
    }

    /// Read an MTL file and return materials
    pub fn read_mtl_file<P: AsRef<Path>>(path: P) -> Result<HashMap<String, Material>> {
        let file = File::open(path)
            .map_err(|e| Error::Io(e))?;
        let reader = BufReader::new(file);
        
        let mut materials = HashMap::new();
        let mut current_material: Option<Material> = None;
        
        for (_line_num, line) in reader.lines().enumerate() {
            let line = line.map_err(|e| Error::Io(e))?;
            let line = line.trim();
            
            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            
            let parts: Vec<&str> = line.split_whitespace().collect();
            if parts.is_empty() {
                continue;
            }
            
            match parts[0] {
                "newmtl" => {
                    // Save previous material
                    if let Some(material) = current_material.take() {
                        materials.insert(material.name.clone(), material);
                    }
                    
                    // Start new material
                    if parts.len() > 1 {
                        current_material = Some(Material::new(parts[1].to_string()));
                    }
                }
                "Ka" => {
                    // Ambient color
                    if let Some(ref mut material) = current_material {
                        if parts.len() >= 4 {
                            if let (Ok(r), Ok(g), Ok(b)) = (
                                parts[1].parse::<f32>(),
                                parts[2].parse::<f32>(),
                                parts[3].parse::<f32>()
                            ) {
                                material.ambient = Some([r, g, b]);
                            }
                        }
                    }
                }
                "Kd" => {
                    // Diffuse color
                    if let Some(ref mut material) = current_material {
                        if parts.len() >= 4 {
                            if let (Ok(r), Ok(g), Ok(b)) = (
                                parts[1].parse::<f32>(),
                                parts[2].parse::<f32>(),
                                parts[3].parse::<f32>()
                            ) {
                                material.diffuse = Some([r, g, b]);
                            }
                        }
                    }
                }
                "Ks" => {
                    // Specular color
                    if let Some(ref mut material) = current_material {
                        if parts.len() >= 4 {
                            if let (Ok(r), Ok(g), Ok(b)) = (
                                parts[1].parse::<f32>(),
                                parts[2].parse::<f32>(),
                                parts[3].parse::<f32>()
                            ) {
                                material.specular = Some([r, g, b]);
                            }
                        }
                    }
                }
                "Ns" => {
                    // Specular exponent
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            if let Ok(ns) = parts[1].parse::<f32>() {
                                material.shininess = Some(ns);
                            }
                        }
                    }
                }
                "d" => {
                    // Transparency (dissolve)
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            if let Ok(d) = parts[1].parse::<f32>() {
                                material.transparency = Some(d);
                            }
                        }
                    }
                }
                "Tr" => {
                    // Transparency (alternative)
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            if let Ok(tr) = parts[1].parse::<f32>() {
                                material.transparency = Some(1.0 - tr); // Tr is inverse of d
                            }
                        }
                    }
                }
                "illum" => {
                    // Illumination model
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            if let Ok(illum) = parts[1].parse::<u32>() {
                                material.illumination = Some(illum);
                            }
                        }
                    }
                }
                "map_Kd" => {
                    // Diffuse texture map
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            material.diffuse_map = Some(parts[1..].join(" "));
                        }
                    }
                }
                "map_Bump" | "bump" => {
                    // Normal/bump map
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            material.normal_map = Some(parts[1..].join(" "));
                        }
                    }
                }
                "map_Ks" => {
                    // Specular map
                    if let Some(ref mut material) = current_material {
                        if parts.len() > 1 {
                            material.specular_map = Some(parts[1..].join(" "));
                        }
                    }
                }
                _ => {
                    // Ignore unknown material properties
                }
            }
        }
        
        // Save the last material
        if let Some(material) = current_material {
            materials.insert(material.name.clone(), material);
        }
        
        Ok(materials)
    }
    
    /// Triangulate a face with arbitrary number of vertices
    fn triangulate_face(vertices: &[FaceVertex]) -> Vec<Vec<FaceVertex>> {
        match vertices.len() {
            3 => {
                // Already a triangle
                vec![vertices.to_vec()]
            }
            4 => {
                // Quad - split into two triangles
                vec![
                    vec![vertices[0], vertices[1], vertices[2]],
                    vec![vertices[0], vertices[2], vertices[3]],
                ]
            }
            n if n > 4 => {
                // N-gon - fan triangulation from first vertex
                let mut triangles = Vec::new();
                for i in 1..(n - 1) {
                    triangles.push(vec![vertices[0], vertices[i], vertices[i + 1]]);
                }
                triangles
            }
            _ => {
                // Degenerate face
                vec![]
            }
        }
    }
    
    /// Convert ObjData to TriangleMesh
    pub fn obj_data_to_mesh(obj_data: &ObjData) -> Result<TriangleMesh> {
        let mut mesh_faces = Vec::new();
        let mut mesh_normals = Vec::new();
        let mut has_normals = false;
        
        // Collect all faces from all groups
        for group in &obj_data.groups {
            for face in &group.faces {
                if face.vertices.len() != 3 {
                    continue; // Skip non-triangular faces (shouldn't happen after triangulation)
                }
                
                // Extract vertex indices
                let face_indices = [
                    face.vertices[0].vertex,
                    face.vertices[1].vertex,
                    face.vertices[2].vertex,
                ];
                
                // Validate vertex indices
                for &idx in &face_indices {
                    if idx >= obj_data.vertices.len() {
                        return Err(Error::InvalidData(
                            format!("Vertex index {} out of range (max: {})", idx, obj_data.vertices.len() - 1)
                        ));
                    }
                }
                
                mesh_faces.push(face_indices);
                
                // Handle normals if available
                if !obj_data.normals.is_empty() {
                    for vertex in &face.vertices {
                        if let Some(normal_idx) = vertex.normal {
                            if normal_idx >= obj_data.normals.len() {
                                return Err(Error::InvalidData(
                                    format!("Normal index {} out of range (max: {})", normal_idx, obj_data.normals.len() - 1)
                                ));
                            }
                            mesh_normals.push(obj_data.normals[normal_idx]);
                            has_normals = true;
                        } else if has_normals {
                            // If some vertices have normals, all should have normals
                            // Use a default normal for consistency
                            mesh_normals.push(Vector3f::new(0.0, 0.0, 1.0));
                        }
                    }
                }
            }
        }
        
        let mut mesh = TriangleMesh::from_vertices_and_faces(obj_data.vertices.clone(), mesh_faces);
        
        // Set normals if available
        if has_normals && mesh_normals.len() == mesh.vertices.len() {
            mesh.set_normals(mesh_normals);
        }
        
        Ok(mesh)
    }
}

impl RobustObjWriter {
    /// Write a complete OBJ file with optional MTL material file
    pub fn write_obj_file<P: AsRef<Path>>(
        obj_data: &ObjData,
        path: P,
        options: &ObjWriteOptions,
    ) -> Result<()> {
        let path = path.as_ref();
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);
        
        // Write header comments
        for comment in &options.comments {
            writeln!(writer, "# {}", comment)?;
        }
        writeln!(writer, "# Vertices: {}", obj_data.vertices.len())?;
        writeln!(writer, "# Texture coordinates: {}", obj_data.texture_coords.len())?;
        writeln!(writer, "# Normals: {}", obj_data.normals.len())?;
        writeln!(writer, "# Groups: {}", obj_data.groups.len())?;
        writeln!(writer)?;
        
        // Write MTL library reference if materials should be written
        if options.write_materials && !obj_data.materials.is_empty() {
            let default_mtl_filename = Self::get_mtl_filename(path);
            let mtl_filename = options.mtl_filename.as_ref()
                .unwrap_or(&default_mtl_filename);
            writeln!(writer, "mtllib {}", mtl_filename)?;
            writeln!(writer)?;
        }
        
        // Write object name if specified
        if let Some(ref object_name) = options.object_name {
            writeln!(writer, "o {}", object_name)?;
            writeln!(writer)?;
        }
        
        // Write vertices
        for vertex in &obj_data.vertices {
            writeln!(writer, "v {} {} {}", vertex.x, vertex.y, vertex.z)?;
        }
        if !obj_data.vertices.is_empty() {
            writeln!(writer)?;
        }
        
        // Write texture coordinates if available and requested
        if options.write_texcoords && !obj_data.texture_coords.is_empty() {
            for tex_coord in &obj_data.texture_coords {
                writeln!(writer, "vt {} {}", tex_coord[0], tex_coord[1])?;
            }
            writeln!(writer)?;
        }
        
        // Write vertex normals if available and requested
        if options.write_normals && !obj_data.normals.is_empty() {
            for normal in &obj_data.normals {
                writeln!(writer, "vn {} {} {}", normal.x, normal.y, normal.z)?;
            }
            writeln!(writer)?;
        }
        
        // Write groups and faces
        for group in &obj_data.groups {
            // Write group name
            let group_name = if group.name == "default" && options.group_name.is_some() {
                options.group_name.as_ref().unwrap()
            } else if group.name != "default" {
                &group.name
            } else {
                "default"
            };
            
            if group_name != "default" || options.group_name.is_some() {
                writeln!(writer, "g {}", group_name)?;
            }
            
            // Track current material
            let mut current_material: Option<&String> = None;
            
            for face in &group.faces {
                // Write material change if needed
                if let Some(ref material) = face.material {
                    if current_material != Some(material) {
                        writeln!(writer, "usemtl {}", material)?;
                        current_material = Some(material);
                    }
                } else if let Some(ref material_name) = options.material_name {
                    if current_material.is_none() {
                        writeln!(writer, "usemtl {}", material_name)?;
                        current_material = Some(material_name);
                    }
                }
                
                // Write face
                write!(writer, "f")?;
                for vertex in &face.vertices {
                    write!(writer, " {}", vertex.vertex + 1)?; // Convert to 1-based indexing
                    
                    // Add texture coordinate if available and requested
                    if options.write_texcoords && !obj_data.texture_coords.is_empty() {
                        if let Some(tex_idx) = vertex.texture {
                            write!(writer, "/{}", tex_idx + 1)?;
                        } else {
                            write!(writer, "/")?;
                        }
                    }
                    
                    // Add normal if available and requested
                    if options.write_normals && !obj_data.normals.is_empty() {
                        if !options.write_texcoords || obj_data.texture_coords.is_empty() {
                            write!(writer, "//")?;
                        } else {
                            write!(writer, "/")?;
                        }
                        
                        if let Some(norm_idx) = vertex.normal {
                            write!(writer, "{}", norm_idx + 1)?;
                        }
                    }
                }
                writeln!(writer)?;
            }
            
            if !group.faces.is_empty() {
                writeln!(writer)?;
            }
        }
        
        // Write MTL file if requested
        if options.write_materials && !obj_data.materials.is_empty() {
            let default_mtl_filename = Self::get_mtl_filename(path);
            let mtl_filename = options.mtl_filename.as_ref()
                .unwrap_or(&default_mtl_filename);
            let mtl_path = path.parent().unwrap_or(Path::new(".")).join(mtl_filename);
            Self::write_mtl_file(&obj_data.materials, &mtl_path)?;
        }
        
        Ok(())
    }
    
    /// Write a TriangleMesh as OBJ with options
    pub fn write_mesh<P: AsRef<Path>>(
        mesh: &TriangleMesh,
        path: P,
        options: &ObjWriteOptions,
    ) -> Result<()> {
        // Convert mesh to ObjData
        let obj_data = Self::mesh_to_obj_data(mesh, options)?;
        Self::write_obj_file(&obj_data, path, options)
    }
    
    /// Write MTL material file
    pub fn write_mtl_file<P: AsRef<Path>>(
        materials: &HashMap<String, Material>,
        path: P,
    ) -> Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);
        
        writeln!(writer, "# MTL file generated by ThreeCrate")?;
        writeln!(writer, "# Materials: {}", materials.len())?;
        writeln!(writer)?;
        
        for (name, material) in materials {
            writeln!(writer, "newmtl {}", name)?;
            
            // Write ambient color
            if let Some(ambient) = material.ambient {
                writeln!(writer, "Ka {} {} {}", ambient[0], ambient[1], ambient[2])?;
            }
            
            // Write diffuse color
            if let Some(diffuse) = material.diffuse {
                writeln!(writer, "Kd {} {} {}", diffuse[0], diffuse[1], diffuse[2])?;
            }
            
            // Write specular color
            if let Some(specular) = material.specular {
                writeln!(writer, "Ks {} {} {}", specular[0], specular[1], specular[2])?;
            }
            
            // Write shininess
            if let Some(shininess) = material.shininess {
                writeln!(writer, "Ns {}", shininess)?;
            }
            
            // Write transparency
            if let Some(transparency) = material.transparency {
                writeln!(writer, "d {}", transparency)?;
            }
            
            // Write illumination model
            if let Some(illumination) = material.illumination {
                writeln!(writer, "illum {}", illumination)?;
            }
            
            // Write texture maps
            if let Some(ref diffuse_map) = material.diffuse_map {
                writeln!(writer, "map_Kd {}", diffuse_map)?;
            }
            
            if let Some(ref normal_map) = material.normal_map {
                writeln!(writer, "map_Bump {}", normal_map)?;
            }
            
            if let Some(ref specular_map) = material.specular_map {
                writeln!(writer, "map_Ks {}", specular_map)?;
            }
            
            writeln!(writer)?;
        }
        
        Ok(())
    }
    
    /// Convert TriangleMesh to ObjData
    fn mesh_to_obj_data(mesh: &TriangleMesh, options: &ObjWriteOptions) -> Result<ObjData> {
        let mut obj_data = ObjData {
            vertices: mesh.vertices.clone(),
            texture_coords: Vec::new(),
            normals: Vec::new(),
            groups: Vec::new(),
            materials: HashMap::new(),
            mtl_files: Vec::new(),
        };
        
        // Add normals if available and requested
        if options.write_normals {
            if let Some(ref normals) = mesh.normals {
                obj_data.normals = normals.clone();
            }
        }
        
        // Create faces with proper indexing
        let mut faces = Vec::new();
        for face_indices in &mesh.faces {
            let mut face_vertices = Vec::new();
            for &vertex_idx in face_indices {
                let face_vertex = FaceVertex {
                    vertex: vertex_idx,
                    texture: None, // No texture coordinates in TriangleMesh
                    normal: if options.write_normals && mesh.normals.is_some() {
                        Some(vertex_idx) // Assume per-vertex normals
                    } else {
                        None
                    },
                };
                face_vertices.push(face_vertex);
            }
            
            faces.push(Face {
                vertices: face_vertices,
                material: options.material_name.clone(),
            });
        }
        
        // Create a single group
        let group_name = options.group_name.clone().unwrap_or_else(|| "default".to_string());
        obj_data.groups.push(Group {
            name: group_name,
            faces,
        });
        
        // Add material if specified
        if let Some(ref material_name) = options.material_name {
            let material = Material::new(material_name.clone());
            obj_data.materials.insert(material_name.clone(), material);
        }
        
        Ok(obj_data)
    }
    
    /// Generate MTL filename from OBJ path
    fn get_mtl_filename(obj_path: &Path) -> String {
        obj_path
            .file_stem()
            .and_then(|s| s.to_str())
            .map(|s| format!("{}.mtl", s))
            .unwrap_or_else(|| "materials.mtl".to_string())
    }
} 