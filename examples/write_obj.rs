//! Example demonstrating OBJ file writing with material support
//! 
//! This example shows how to:
//! - Write OBJ files with vertices, normals, texture coordinates
//! - Generate MTL material files with texture maps
//! - Handle groups and materials
//! - Use various write options
//! - Round-trip test reading and writing

use std::collections::HashMap;
use threecrate_core::{TriangleMesh, Point3f, Vector3f};
use threecrate_io::{RobustObjWriter, RobustObjReader, ObjData, ObjWriteOptions, Material, FaceVertex, Face, Group};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("=== OBJ Writer Example ===\n");
    
    // Method 1: Simple mesh writing
    println!("1. Writing simple mesh:");
    write_simple_mesh()?;
    
    // Method 2: Writing mesh with normals and materials
    println!("2. Writing mesh with normals and materials:");
    write_mesh_with_materials()?;
    
    // Method 3: Writing complex OBJ data with groups and textures
    println!("3. Writing complex OBJ data:");
    write_complex_obj_data()?;
    
    // Method 4: Round-trip testing
    println!("4. Round-trip testing:");
    test_round_trip()?;
    
    // Method 5: MTL file generation
    println!("5. Standalone MTL file generation:");
    write_mtl_file()?;
    
    println!("All examples completed successfully!");
    Ok(())
}

fn write_simple_mesh() -> Result<(), Box<dyn std::error::Error>> {
    // Create a simple triangle mesh
    let vertices = vec![
        Point3f::new(0.0, 0.0, 0.0),
        Point3f::new(1.0, 0.0, 0.0),
        Point3f::new(0.5, 1.0, 0.0),
    ];
    let faces = vec![[0, 1, 2]];
    let mesh = TriangleMesh::from_vertices_and_faces(vertices, faces);
    
    // Write with basic options
    let options = ObjWriteOptions::new()
        .with_comment("Simple triangle mesh")
        .with_comment("Generated by ThreeCrate example")
        .with_object_name("triangle")
        .with_normals(false); // No normals for this simple example
    
    RobustObjWriter::write_mesh(&mesh, "simple_triangle.obj", &options)?;
    
    println!("   ✓ Created simple_triangle.obj");
    
    // Show the contents
    let content = std::fs::read_to_string("simple_triangle.obj")?;
    println!("   File contents:");
    for line in content.lines().take(10) {
        println!("     {}", line);
    }
    println!();
    
    Ok(())
}

fn write_mesh_with_materials() -> Result<(), Box<dyn std::error::Error>> {
    // Create a mesh with normals
    let vertices = vec![
        Point3f::new(0.0, 0.0, 0.0),
        Point3f::new(2.0, 0.0, 0.0),
        Point3f::new(1.0, 1.732, 0.0), // Equilateral triangle
        Point3f::new(1.0, 0.577, 1.633), // Pyramid tip
    ];
    
    let faces = vec![
        [0, 1, 2], // Base
        [0, 3, 1], // Side 1
        [1, 3, 2], // Side 2
        [2, 3, 0], // Side 3
    ];
    
    let normals = vec![
        Vector3f::new(0.0, 0.0, -1.0), // Base points down
        Vector3f::new(-0.816, -0.471, 0.333),
        Vector3f::new(0.0, -0.943, 0.333),
        Vector3f::new(0.816, -0.471, 0.333),
    ];
    
    let mut mesh = TriangleMesh::from_vertices_and_faces(vertices, faces);
    mesh.set_normals(normals);
    
    // Write with materials enabled
    let options = ObjWriteOptions::new()
        .with_comment("Pyramid mesh with materials")
        .with_object_name("pyramid")
        .with_group_name("pyramid_faces")
        .with_normals(true)
        .with_materials(true)
        .with_material_name("red_plastic");
    
    RobustObjWriter::write_mesh(&mesh, "pyramid_with_material.obj", &options)?;
    
    println!("   ✓ Created pyramid_with_material.obj and pyramid_with_material.mtl");
    
    // Verify both files were created
    assert!(std::path::Path::new("pyramid_with_material.obj").exists());
    assert!(std::path::Path::new("pyramid_with_material.mtl").exists());
    
    // Show OBJ contents
    let obj_content = std::fs::read_to_string("pyramid_with_material.obj")?;
    println!("   OBJ file preview:");
    for line in obj_content.lines().take(15) {
        println!("     {}", line);
    }
    
    // Show MTL contents
    let mtl_content = std::fs::read_to_string("pyramid_with_material.mtl")?;
    println!("   MTL file preview:");
    for line in mtl_content.lines().take(8) {
        println!("     {}", line);
    }
    println!();
    
    Ok(())
}

fn write_complex_obj_data() -> Result<(), Box<dyn std::error::Error>> {
    // Create complex OBJ data with multiple groups and materials
    let vertices = vec![
        // Cube vertices
        Point3f::new(-1.0, -1.0, -1.0), // 0
        Point3f::new( 1.0, -1.0, -1.0), // 1
        Point3f::new( 1.0,  1.0, -1.0), // 2
        Point3f::new(-1.0,  1.0, -1.0), // 3
        Point3f::new(-1.0, -1.0,  1.0), // 4
        Point3f::new( 1.0, -1.0,  1.0), // 5
        Point3f::new( 1.0,  1.0,  1.0), // 6
        Point3f::new(-1.0,  1.0,  1.0), // 7
    ];
    
    let texture_coords = vec![
        [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // Basic quad UVs
        [0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0], // Repeat for other faces
    ];
    
    let normals = vec![
        Vector3f::new( 0.0,  0.0, -1.0), // Front
        Vector3f::new( 0.0,  0.0,  1.0), // Back
        Vector3f::new(-1.0,  0.0,  0.0), // Left
        Vector3f::new( 1.0,  0.0,  0.0), // Right
        Vector3f::new( 0.0, -1.0,  0.0), // Bottom
        Vector3f::new( 0.0,  1.0,  0.0), // Top
    ];
    
    // Create materials
    let mut materials = HashMap::new();
    
    let mut red_material = Material::new("red_side".to_string());
    red_material.diffuse = Some([0.8, 0.2, 0.2]);
    red_material.specular = Some([0.9, 0.9, 0.9]);
    red_material.shininess = Some(32.0);
    red_material.illumination = Some(2);
    materials.insert("red_side".to_string(), red_material);
    
    let mut blue_material = Material::new("blue_side".to_string());
    blue_material.diffuse = Some([0.2, 0.2, 0.8]);
    blue_material.specular = Some([0.9, 0.9, 0.9]);
    blue_material.shininess = Some(64.0);
    blue_material.illumination = Some(2);
    materials.insert("blue_side".to_string(), blue_material);
    
    let mut green_material = Material::new("green_top_bottom".to_string());
    green_material.diffuse = Some([0.2, 0.8, 0.2]);
    green_material.specular = Some([0.5, 0.5, 0.5]);
    green_material.shininess = Some(16.0);
    green_material.illumination = Some(1);
    materials.insert("green_top_bottom".to_string(), green_material);
    
    // Create faces for different groups
    let red_faces = vec![
        Face {
            vertices: vec![
                FaceVertex { vertex: 0, texture: Some(0), normal: Some(2) },
                FaceVertex { vertex: 4, texture: Some(1), normal: Some(2) },
                FaceVertex { vertex: 7, texture: Some(2), normal: Some(2) },
            ],
            material: Some("red_side".to_string()),
        },
        Face {
            vertices: vec![
                FaceVertex { vertex: 0, texture: Some(0), normal: Some(2) },
                FaceVertex { vertex: 7, texture: Some(2), normal: Some(2) },
                FaceVertex { vertex: 3, texture: Some(3), normal: Some(2) },
            ],
            material: Some("red_side".to_string()),
        },
    ];
    
    let blue_faces = vec![
        Face {
            vertices: vec![
                FaceVertex { vertex: 1, texture: Some(0), normal: Some(3) },
                FaceVertex { vertex: 2, texture: Some(1), normal: Some(3) },
                FaceVertex { vertex: 6, texture: Some(2), normal: Some(3) },
            ],
            material: Some("blue_side".to_string()),
        },
        Face {
            vertices: vec![
                FaceVertex { vertex: 1, texture: Some(0), normal: Some(3) },
                FaceVertex { vertex: 6, texture: Some(2), normal: Some(3) },
                FaceVertex { vertex: 5, texture: Some(3), normal: Some(3) },
            ],
            material: Some("blue_side".to_string()),
        },
    ];
    
    let green_faces = vec![
        // Top face
        Face {
            vertices: vec![
                FaceVertex { vertex: 3, texture: Some(0), normal: Some(5) },
                FaceVertex { vertex: 7, texture: Some(1), normal: Some(5) },
                FaceVertex { vertex: 6, texture: Some(2), normal: Some(5) },
            ],
            material: Some("green_top_bottom".to_string()),
        },
        Face {
            vertices: vec![
                FaceVertex { vertex: 3, texture: Some(0), normal: Some(5) },
                FaceVertex { vertex: 6, texture: Some(2), normal: Some(5) },
                FaceVertex { vertex: 2, texture: Some(3), normal: Some(5) },
            ],
            material: Some("green_top_bottom".to_string()),
        },
        // Bottom face
        Face {
            vertices: vec![
                FaceVertex { vertex: 0, texture: Some(0), normal: Some(4) },
                FaceVertex { vertex: 1, texture: Some(1), normal: Some(4) },
                FaceVertex { vertex: 5, texture: Some(2), normal: Some(4) },
            ],
            material: Some("green_top_bottom".to_string()),
        },
        Face {
            vertices: vec![
                FaceVertex { vertex: 0, texture: Some(0), normal: Some(4) },
                FaceVertex { vertex: 5, texture: Some(2), normal: Some(4) },
                FaceVertex { vertex: 4, texture: Some(3), normal: Some(4) },
            ],
            material: Some("green_top_bottom".to_string()),
        },
    ];
    
    // Create groups
    let groups = vec![
        Group {
            name: "red_sides".to_string(),
            faces: red_faces,
        },
        Group {
            name: "blue_sides".to_string(),
            faces: blue_faces,
        },
        Group {
            name: "green_top_bottom".to_string(),
            faces: green_faces,
        },
    ];
    
    let obj_data = ObjData {
        vertices,
        texture_coords,
        normals,
        groups,
        materials,
        mtl_files: vec!["complex_cube.mtl".to_string()],
    };
    
    // Write with all options enabled
    let options = ObjWriteOptions::new()
        .with_comment("Complex cube with multiple groups and materials")
        .with_comment("Demonstrates texture coordinates, normals, and materials")
        .with_object_name("textured_cube")
        .with_normals(true)
        .with_texcoords(true)
        .with_materials(true);
    
    RobustObjWriter::write_obj_file(&obj_data, "complex_cube.obj", &options)?;
    
    println!("   ✓ Created complex_cube.obj and complex_cube.mtl");
    
    // Show statistics
    println!("   Statistics:");
    println!("     - {} vertices", obj_data.vertices.len());
    println!("     - {} texture coordinates", obj_data.texture_coords.len());
    println!("     - {} normals", obj_data.normals.len());
    println!("     - {} groups", obj_data.groups.len());
    println!("     - {} materials", obj_data.materials.len());
    println!();
    
    Ok(())
}

fn test_round_trip() -> Result<(), Box<dyn std::error::Error>> {
    // Create original mesh
    let vertices = vec![
        Point3f::new(0.0, 0.0, 0.0),
        Point3f::new(1.0, 0.0, 0.0),
        Point3f::new(0.5, 1.0, 0.0),
        Point3f::new(0.5, 0.5, 1.0),
    ];
    
    let faces = vec![
        [0, 1, 2],
        [0, 3, 1],
        [1, 3, 2],
        [2, 3, 0],
    ];
    
    let normals = vec![
        Vector3f::new(0.0, 0.0, -1.0),
        Vector3f::new(-0.816, -0.471, 0.333),
        Vector3f::new(0.816, -0.471, 0.333),
        Vector3f::new(0.0, 0.943, 0.333),
    ];
    
    let mut original_mesh = TriangleMesh::from_vertices_and_faces(vertices, faces);
    original_mesh.set_normals(normals);
    
    // Write the mesh
    let options = ObjWriteOptions::new()
        .with_comment("Round-trip test mesh")
        .with_normals(true)
        .with_materials(true)
        .with_material_name("test_material");
    
    RobustObjWriter::write_mesh(&original_mesh, "roundtrip_test.obj", &options)?;
    
    // Read it back
    let loaded_mesh = threecrate_io::read_mesh("roundtrip_test.obj")?;
    
    // Compare
    println!("   Round-trip comparison:");
    println!("     Original: {} vertices, {} faces", 
             original_mesh.vertex_count(), original_mesh.face_count());
    println!("     Loaded:   {} vertices, {} faces", 
             loaded_mesh.vertex_count(), loaded_mesh.face_count());
    
    // Verify vertices match (within floating point precision)
    let mut max_error = 0.0f32;
    for (orig, loaded) in original_mesh.vertices.iter().zip(loaded_mesh.vertices.iter()) {
        let error = ((orig.x - loaded.x).powi(2) + 
                     (orig.y - loaded.y).powi(2) + 
                     (orig.z - loaded.z).powi(2)).sqrt();
        max_error = max_error.max(error);
    }
    
    println!("     Maximum vertex error: {:.2e}", max_error);
    
    // Verify normals if present
    if let (Some(orig_normals), Some(loaded_normals)) = (&original_mesh.normals, &loaded_mesh.normals) {
        let mut max_normal_error = 0.0f32;
        for (orig, loaded) in orig_normals.iter().zip(loaded_normals.iter()) {
            let error = ((orig.x - loaded.x).powi(2) + 
                         (orig.y - loaded.y).powi(2) + 
                         (orig.z - loaded.z).powi(2)).sqrt();
            max_normal_error = max_normal_error.max(error);
        }
        println!("     Maximum normal error: {:.2e}", max_normal_error);
    }
    
    println!("   ✓ Round-trip test passed!");
    println!();
    
    Ok(())
}

fn write_mtl_file() -> Result<(), Box<dyn std::error::Error>> {
    // Create a collection of materials
    let mut materials = HashMap::new();
    
    // Plastic material
    let mut plastic = Material::new("red_plastic".to_string());
    plastic.ambient = Some([0.1, 0.05, 0.05]);
    plastic.diffuse = Some([0.8, 0.1, 0.1]);
    plastic.specular = Some([0.9, 0.9, 0.9]);
    plastic.shininess = Some(32.0);
    plastic.transparency = Some(1.0);
    plastic.illumination = Some(2);
    plastic.diffuse_map = Some("red_plastic_diffuse.jpg".to_string());
    plastic.normal_map = Some("red_plastic_normal.jpg".to_string());
    materials.insert("red_plastic".to_string(), plastic);
    
    // Metal material
    let mut metal = Material::new("brushed_metal".to_string());
    metal.ambient = Some([0.2, 0.2, 0.2]);
    metal.diffuse = Some([0.3, 0.3, 0.3]);
    metal.specular = Some([0.95, 0.95, 0.95]);
    metal.shininess = Some(128.0);
    metal.transparency = Some(1.0);
    metal.illumination = Some(2);
    metal.diffuse_map = Some("metal_diffuse.jpg".to_string());
    metal.specular_map = Some("metal_specular.jpg".to_string());
    materials.insert("brushed_metal".to_string(), metal);
    
    // Glass material
    let mut glass = Material::new("clear_glass".to_string());
    glass.ambient = Some([0.0, 0.0, 0.0]);
    glass.diffuse = Some([0.1, 0.1, 0.1]);
    glass.specular = Some([1.0, 1.0, 1.0]);
    glass.shininess = Some(96.0);
    glass.transparency = Some(0.2);
    glass.illumination = Some(4);
    materials.insert("clear_glass".to_string(), glass);
    
    // Write MTL file
    RobustObjWriter::write_mtl_file(&materials, "example_materials.mtl")?;
    
    println!("   ✓ Created example_materials.mtl with {} materials", materials.len());
    
    // Show contents
    let content = std::fs::read_to_string("example_materials.mtl")?;
    println!("   MTL file preview:");
    for line in content.lines().take(20) {
        println!("     {}", line);
    }
    if content.lines().count() > 20 {
        println!("     ... ({} more lines)", content.lines().count() - 20);
    }
    println!();
    
    // Test reading it back
    let loaded_materials = RobustObjReader::read_mtl_file("example_materials.mtl")?;
    println!("   ✓ Successfully read back {} materials", loaded_materials.len());
    
    for (name, material) in &loaded_materials {
        println!("     - {}: diffuse={:?}, transparency={:?}", 
                 name, material.diffuse, material.transparency);
    }
    println!();
    
    Ok(())
}

// Cleanup function (called automatically when the program ends)
impl Drop for CleanupOnExit {
    fn drop(&mut self) {
        let files = [
            "simple_triangle.obj",
            "pyramid_with_material.obj",
            "pyramid_with_material.mtl",
            "complex_cube.obj",
            "complex_cube.mtl",
            "roundtrip_test.obj",
            "roundtrip_test.mtl",
            "example_materials.mtl",
        ];
        
        for file in &files {
            let _ = std::fs::remove_file(file);
        }
    }
}

#[allow(dead_code)]
struct CleanupOnExit;

#[allow(dead_code)]
static _CLEANUP: CleanupOnExit = CleanupOnExit;
